import numpy as np
from scipy.optimize import least_squares, root
from helper.setup_project import generate_model, clicking_function_squared


def minimize_combined(x, d, p, ctr):
    num_rounds = np.shape(p)[0]

    sensitivity = x[:d*d].reshape((d, d), order='C')
    theta = x[d*d:]
    x = sensitivity @ p.T

    row_stochastic = np.sum(sensitivity, axis=1) - np.ones(d)
    clicking = 0.5*(1 - np.tile(theta, num_rounds).T) + np.tile(theta, num_rounds).T*np.exp(-4*(x.flatten(order='F') - p.flatten(order='C'))**2) - ctr.flatten(order='C')

    return np.concatenate((clicking, row_stochastic))


np.set_printoptions(precision=4, suppress=True)
d = 5

for i in range(1):
    sim, P, CTR, _, true_sensitivity = generate_model(num_measurements=20, ideal=True, clicking_function='combined')

    print("True sensitivity:\n", true_sensitivity)
    print("True col sums: \n", true_sensitivity.sum(axis=0))

    #print(CTR)

    estimated_sensitivity = 0

    
    result = least_squares(minimize_combined, np.concatenate((np.zeros(d*d), np.ones(d))), bounds=(np.zeros(d*d + d), np.concatenate((np.ones(d*d), 2*np.ones(d)))), verbose=1, args=(d, P, CTR)).x
    estimated_sensitivity = result[:d*d]
    estimated_sensitivity[np.abs(estimated_sensitivity) < 1e-10] = 0
    theta = result[d*d:]    
    print("Estimated theta:", theta)


    print("Estimated sensitivity:\n", estimated_sensitivity.reshape((d, d), order='C'))

    print("Estimated col sums: \n", estimated_sensitivity.reshape((d, d), order='C').sum(axis=0))
    print("Estimated row sums: \n", estimated_sensitivity.reshape((d, d), order='C').sum(axis=1))
        
    